// ==========================================
// Prisma Schema for Multi-Exchange Integration
// ==========================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =====================
// User & Authentication
// =====================
model User {
  id                Int       @id @default(autoincrement())
  email             String    @unique
  password          String
  name              String?
  role              String    @default("user")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  resetToken        String?
  resetTokenExp     DateTime?
  isVerified        Boolean   @default(false)
  verificationToken String?
  status            String    @default("active")
  tokenVersion      Int       @default(0)
  free              Float     @default(0)
  used              Float     @default(0)
  total             Float     @default(0)
  lastActivity      DateTime?

  // Relations
  trades            Trade[]
  alerts            AlertLog[]
  exchanges         UserExchangeAccount[]
  logs              Log[]
  positions         Position[]
  balances          Balance[]
  syncLogs          SyncLog[]
  dailyPnLSnapshots DailyPnLSnapshot[]
  tradeEvents       TradeEvent[]
  executions        Execution[] // âœ… Add this line
}

// ==============
// Core Data
// ==============
model Trade {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  exchange  String
  symbol    String
  side      String
  amount    Float
  price     Float
  fee       Float? // optional for future fee tracking
  pnl       Float? // profit/loss
  tradeTime DateTime @default(now())
  status    String   @default("completed") // completed, pending, failed
}

// ====================
// Alerts (TradingView)
// ====================
model AlertLog {
  id         Int      @id @default(autoincrement())
  user       User?    @relation(fields: [userId], references: [id])
  userId     Int?
  exchange   String
  symbol     String
  action     String
  tp         Float?
  sl         Float?
  rawPayload Json
  status     String   @default("pending")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// =====================
// Unified Exchange Account
// =====================
model UserExchangeAccount {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  provider   String // Binance, OKX, Bybit, Coinbase, Blofin, Bitunix
  ccxtId     String? // e.g., binance, okx, bybit
  type       String? // spot, futures
  apiKey     String
  apiSecret  String
  passphrase String?
  label      String? // optional user label
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([userId, provider, type])
}

// =====================
// Balances Table
// =====================
model Balance {
  id             Int      @id @default(autoincrement())
  user           User     @relation(fields: [userId], references: [id])
  userId         Int
  exchange       String
  asset          String
  free           Float    @default(0)
  used           Float    @default(0)
  total          Float    @default(0)
  totalPositions Int      @default(0) // Added for UserDashboard
  fetchedAt      DateTime @default(now())

  @@unique([userId, exchange, asset])
}

// =====================
// Positions / Orders
// =====================
model Position {
  id           Int       @id @default(autoincrement())
  user         User      @relation(fields: [userId], references: [id])
  userId       Int
  exchange     String
  symbol       String
  side         String    // "buy" or "sell"
  amount       Float     // original size
  entryPrice   Float
  currentPrice Float?
  pnl          Float?    // unrealized
  status       String    @default("open") // "open", "closed"
  openedAt     DateTime  @default(now())
  closedAt     DateTime?
  closePrice   Float?    // when closed
  realizedPnl  Float?    // when closed
  chartId      String?   // e.g., "3L" â€” your custom ID
  alertId      String?   // optional: link to AlertLog
  leverage     Float?
  // ðŸ”¹ New: track remaining size (for partial closes)
  remainingSize Float    @default(0) // updated on partial close
}

// =====================
// Exchange Metadata
// =====================
model ExchangeMeta {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  ccxtId    String
  type      String? // spot/futures
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())

  @@unique([ccxtId, type]) // âœ… allows same ccxtId for different types
}

// =====================
// Logging & Sync Tracking
// =====================
model Log {
  id        Int      @id @default(autoincrement())
  user      User?    @relation(fields: [userId], references: [id])
  userId    Int?
  tvId      String?
  exchange  String?
  symbol    String?
  request   String?
  message   String
  level     String   @default("INFO")
  createdAt DateTime @default(now())
}

model SyncLog {
  id        Int      @id @default(autoincrement())
  user      User?    @relation(fields: [userId], references: [id])
  userId    Int?
  exchange  String
  type      String // balances, orders, positions, trades
  status    String   @default("success")
  message   String?
  createdAt DateTime @default(now())
}

model DailyPnLSnapshot {
  id                 Int      @id @default(autoincrement())
  userId             Int
  user               User     @relation(fields: [userId], references: [id])
  date               DateTime @db.Date // e.g., 2025-10-23
  totalBalance       Float
  totalUnrealizedPnl Float
  totalRealizedPnl   Float
  positions          Json // optional: store full position list for debugging
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([userId, date])
}

model TradeEvent {
  id          Int       @id @default(autoincrement())
  userId      Int
  user        User      @relation(fields: [userId], references: [id])
  symbol      String
  side        String // "buy" or "sell"
  size        Float
  entryPrice  Float
  closePrice  Float?
  realizedPnl Float?
  status      String // "open", "closed"
  closedAt    DateTime? // when trade was closed
  createdAt   DateTime  @default(now())
}

model Execution {
  id           Int      @id @default(autoincrement())
  execId       String   @unique  // âœ… Unique Bybit execution ID
  userId       Int
  user         User     @relation(fields: [userId], references: [id])
  symbol       String
  side         String
  qty          Float
  price        Float
  closedPnl    Float
  fee          Float?
  execTime     DateTime
  balanceAfter Float?

  @@index([userId, execTime])
}
